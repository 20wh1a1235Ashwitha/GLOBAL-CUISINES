# -*- coding: utf-8 -*-
"""Copy of GLOBAL CUISINES.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dngGWW2lt3AHDyq-mZWRmv1_O-SgaPfz
"""

import numpy as np
import pandas as pd

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import matplotlib.pyplot as plt
df_train = pd.read_json('/content/train.json')
df_train.head()

"""**Data Preprocessing**"""

df_train.isnull().sum()

"""**Count of cuisines in dataset**"""

#cuisine count in the dataset
plt.style.use('ggplot')
df_train['cuisine'].value_counts().plot(kind='bar')

"""**Most frequent ingredients for each cuisine**"""

#counter is a dictionary which counts the frequency of each ingredient for every unique cuisine
from collections import Counter
counters = {}
for cuisine in df_train['cuisine'].unique():
    counters[cuisine] = Counter()
    indices = (df_train['cuisine'] == cuisine)
    for ingredients in df_train[indices]['ingredients']:
        counters[cuisine].update(ingredients)

#count of common ingredients in italian
counters['italian'].most_common(10)

top10 = pd.DataFrame([[items[0] for items in counters[cuisine].most_common(10)] for cuisine in counters],
            index=[cuisine for cuisine in counters],
            columns=['top{}'.format(i) for i in range(1, 11)])
top10

"""**Add new column every_ingredients**"""

#adding a new column as every_ingredients which maps every ingredients as a string separated by a semi colon
df_train['every_ingredients'] = df_train['ingredients'].map(";".join)
df_train.head()

"""**Check for the presence of an ingredient in recipe**"""

#it checks in every_ingredients columns whether pepper is present or not...
df_train['every_ingredients'].str.contains('pepper')

#shows how many dishes in each cuisine contains pepper in every_ingredients column
indices = df_train['every_ingredients'].str.contains('pepper')
df_train[indices]['cuisine'].value_counts().plot(kind='bar',
                                                 title='pepper as found per cuisine')

"""**Unique Ingredients**"""

#np.unique() is used to return unique ingredients from top10 array and store each in object called unique and then flatten into 1D array
import numpy as np
unique = np.unique(top10.values.ravel())
unique

len(unique)

#creates a plot for each unique ingredient in 1D array of range 64
#finds whether every unique ingedient is present in every_ingredients coloum(boolean function)
#finds the frequency of each unique ingredient using counts() function
fig, axes = plt.subplots(8, 8, figsize=(20, 20))
for ingredient, ax_index in zip(unique, range(64)):
    indices = df_train['every_ingredients'].str.contains(ingredient)
    relative_freq = (df_train[indices]['cuisine'].value_counts() / df_train['cuisine'].value_counts())
    relative_freq.plot(kind='bar', ax=axes.ravel()[ax_index], fontsize=7, title=ingredient)

from sklearn.feature_extraction.text import CountVectorizer

#Dataframe(every_ingredients column)(text data) is transformed into matrix X
#values of matrix represents count of each ingredient in each cuisine
cv = CountVectorizer()
X = cv.fit_transform(df_train['every_ingredients'].values)
X.shape

print(list(cv.vocabulary_.keys())[:100])

"""**Unique Cuisines**"""

df_train.describe(include='all')

"""**Data Wrangling**"""

#converting categorical data into numerical data
#asigning unique values for each unique cuisine
from sklearn.preprocessing import LabelEncoder
enc = LabelEncoder()
y = enc.fit_transform(df_train.cuisine)
y[:100]

#returning array consisting of unique cuisines
enc.classes_

from sklearn.preprocessing import StandardScaler

from sklearn.linear_model import LogisticRegression

"""**Logistic Regression**"""

#importing the tarin_test_split function
#splitting the training dataset into X_train and y_train
#testing dataset into X_test and y_test
#assigning LogisticRegression() function to object logistic
#training the logistic model
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
from sklearn.linear_model import LogisticRegression
logistic = LogisticRegression()
logistic.fit(X_train, y_train)

from sklearn.metrics import accuracy_score

m = logistic.predict(X_test)
lgac = accuracy_score(m,y_test)
lgac

import joblib
joblib.dump(logistic, "logistic_regression_model.joblib")

# Load the model from the file
logistic_loaded = joblib.load("logistic_regression_model.joblib")

"""**Decision Tree**"""

from sklearn.tree import DecisionTreeClassifier

#training DecisionTree model
tree = DecisionTreeClassifier()
tree.fit(X_train, y_train)

from sklearn.metrics import accuracy_score

ac = tree.predict(X_test)
actree = accuracy_score(ac,y_test)
actree

"""**KNN**"""

from sklearn.neighbors import KNeighborsClassifier

#training KNN model
neighbor=KNeighborsClassifier()
neighbor.fit(X_train,y_train)

from sklearn.metrics import accuracy_score

o =neighbor.predict(X_test)
f = accuracy_score(o,y_test)
f

"""**Comparision Table**"""

models=pd.DataFrame({
    'Model':['Logistic Regression','Decision Tree','K-Nearest Neighbours'],
    'Score':[lgac,actree,f]})
models.sort_values(by='Score',ascending=False)

data = {'Logistic Regression':0.774859,'K-Nearest Neighbours':0.630547,'Decision Tree':0.633061}
models = list(data.keys())
score = list(data.values())
plt.figure(figsize=(15,5))

plt.bar(models,score, color ='blue',width=0.5)
plt.show()

"""**Confusion Matrix**"""

#Inspecting the classification results using a confusion matrix
#Compares actual and predicted values and shows percentage of correct predictions for each cuisine
from sklearn.metrics import confusion_matrix

plt.figure(figsize=(10, 10))

cm = confusion_matrix(y_test, logistic.predict(X_test))
cm_normalized = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]

plt.imshow(cm_normalized, interpolation='nearest')
plt.title("confusion matrix")
plt.colorbar(shrink=0.3)
cuisines = df_train['cuisine'].value_counts().index
tick_marks = np.arange(len(cuisines))
plt.xticks(tick_marks, cuisines, rotation=90)
plt.yticks(tick_marks, cuisines)
plt.tight_layout()
plt.ylabel('True label')
plt.xlabel('Predicted label')

"""**Classification Report**"""

from sklearn.metrics import classification_report

#it generates a classification report by compaqring the y_predicted values against the y_test values


y_pred = logistic.predict(X_test)
print(classification_report(y_test, y_pred, target_names=cuisines))

import json
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
import joblib

# Load the training data from JSON
with open("train.json") as f:
    train_data = json.load(f)

# Convert the training data to a pandas DataFrame with cuisine and ingredients
train = pd.DataFrame(train_data)
train = train[["cuisine", "ingredients"]]

# Load the CountVectorizer object
vectorizer = CountVectorizer(stop_words='english')

# Transform the training data
# Transform the training data
train['ingredients_str'] = train['ingredients'].apply(lambda x: ' '.join(x))
train_vectors = vectorizer.fit_transform(train['ingredients_str'])


# Train a logistic regression model
logistic = LogisticRegression(max_iter=1000)
logistic.fit(train_vectors, train['cuisine'])

# Save the model to a file
joblib.dump(logistic, "logistic_regression_model.joblib")

# Load the model from the file
logistic_loaded = joblib.load("logistic_regression_model.joblib")

# Load the test data from JSON
with open("test.json") as f:
    test_data = json.load(f)

# Convert the test data to a pandas DataFrame with ID and ingredients
test = pd.DataFrame(test_data)
test = test[["id", "ingredients"]]

# Transform the test data using the same CountVectorizer object
test_vectors = vectorizer.transform(test['ingredients'].apply(lambda x: ' '.join(x)))


# Make predictions on the test data using the loaded logistic regression model
test_predictions = logistic_loaded.predict(test_vectors)

# Add the predicted cuisine column to the test DataFrame
test['cuisine'] = test_predictions

# Save the test DataFrame with ID and predicted cuisine to a CSV file
test[['id', 'cuisine']].to_csv('submission.csv', index=False)

"""**Output**"""

test[['id', 'cuisine']]

!pip install -q gradio

import json
import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.linear_model import LogisticRegression
import gradio as gr

# Load the training data from the JSON file into a pandas DataFrame
with open('train.json') as f:
    train_data = json.load(f)

train_df = pd.DataFrame(train_data)

# Create a CountVectorizer object to transform the ingredient lists into a bag of words representation
vectorizer = CountVectorizer()
train_X = vectorizer.fit_transform(train_df['ingredients'].apply(lambda x: ' '.join(x)))
train_y = train_df['cuisine']
# Train a logistic regression model on the training data
lr_model = LogisticRegression(max_iter=1000)
lr_model.fit(train_X, train_y)

# Define the Gradio interface
def predict_cuisine(id, ingredients):
    # Transform the input ingredient list using the CountVectorizer object
    ingredients_list = ingredients.split(',')
    input_X = vectorizer.transform([' '.join(ingredients_list)])

    # Use the trained logistic regression model to make a prediction
    prediction = lr_model.predict(input_X)[0]

    return prediction

# Define the input and output interfaces for Gradio
id_input = gr.inputs.Textbox(label="Enter the recipe id")
ingredients_input = gr.inputs.Textbox(label="Enter a list of ingredients separated by commas")
cuisine_output = gr.outputs.Textbox(label="Predicted Cuisine")

# Launch the Gradio interface
gr.Interface(predict_cuisine, inputs=[id_input, ingredients_input], outputs=cuisine_output, title="Cuisine Predictor").launch()

# id = 22213 ; ingredients = water,vegetable oil,wheat,salt ; cuisine = indian
# id = 12734 ; ingredients = chopped tomatoes,fresh basil,garlic,extra-virgin olive oil,kosher salt,flat leaf parsley ; cuisine = italian
# id = 41995 ; ingredients = ground cinnamon,fresh cilantro,chili powder,ground coriander,kosher salt,ground black pepper,garlic,plum tomatoes,avocado,lime juice,flank steak,saltground cumin,black pepper,olive oil,crushed red pepper flakes,onions ; cuisine = mexican